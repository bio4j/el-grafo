<!doctype html>

<meta charset="utf-8">
<title>sentence-tokenization</title>

<script src="scripts/lib/graphlib.js"></script>
<script src="scripts/lib/d3.js"></script>
<!-- <script src="js/dagre-d3.js"></script> -->
<script src="scripts/lib/dagre-d3_c.js"></script>

<script src="scripts/alg/topsort.js"></script>
<script src="scripts/alg/tarjan.js"></script>
<script src="scripts/alg/components.js"></script>
<script src="scripts/alg/dijkstra.js"></script>
<script src="scripts/alg/dijkstraAll.js"></script>
<script src="scripts/alg/findCycles.js"></script>
<script src="scripts/alg/floydWarshall.js"></script>
<script src="scripts/alg/isAcyclic.js"></script>
<script src="scripts/alg/postorder.js"></script>
<script src="scripts/alg/preorder.js"></script>
<script src="scripts/alg/prim.js"></script>


<style>
g.type-TK > rect {
  fill:teal;
}

g.type-NP > rect {
  fill:lightblue;
}

g.type-DT > rect {
  fill:#FFCC00;
}

svg {
  border: 1px solid #999;
  overflow: hidden;
}

/*text {
  font-weight: 300;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
  font-size: 14px;
}*/

/*Node-labels*/
.node text {
  font-weight: 300;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
  font-size: 16px;
  fill: black;
}

/*Edge-labels*/
.edgeLabel text {
  font-weight: 300;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
  font-size: 9px;
  fill: grey;
}

.node rect {
  stroke: #999;
  stroke-width: 1px;
  fill: #fff;
}

/*node hover works*/
/*.node:hover rect {
  cursor: pointer;
  fill: lightgrey;
}
*/
.edgeLabel rect {
  fill: none;
  /*fill: #fff;*/
  pointer-events: none;
}

.edgePath path {
  stroke: #333;
  stroke-width: 1.5px;
  fill: none;
  stroke-dasharray: 1, 4, 1, 4;
  pointer-events:all;
}

/*path hover works*/
.edgePath:hover path {
  stroke: orange;
  stroke-width: 3px;
  stroke-dasharray: 10, 0;
}

/*g.oneToMany > path {
  stroke: red;
  stroke-width: 1.5px;
  fill: none;
}*/

svg text {
        pointer-events: none;
}

</style>
<body>
<h2>dagre-d3: Example2 sentence-tokenization</h2>
<div id="attach">
  <svg id="svg-canvas" width=800 height=600>
    <g transform="translate(20, 20)"/>
  </svg>
</div>

<script>

/*  
//Width and height
var w = 800,
    h = 600;

//Escala de colores por defecto hasta 20 elementos
var color = d3.scale.category20();

//Create SVG element
var svg = d3.select("div")
    .attr("id", "attach")
    .append("svg")
    .attr("id", "svg-canvas")
    .attr("w", w)
    .attr("h", h);
    .attr("transform", "translate(20, 20)");
  
*/


  //Graph data:
  var g = new dagreD3.Digraph();
  g.addNode(0,  { label: "0",   label2: "TOP",       nodeclass: "type-TOP" });
  g.addNode(1,  {  label: "1",   label2: "S lalalala",         nodeclass: "type-S" });
  g.addNode(2,  {  label: "2",   label2: "NP",        nodeclass: "type-NP" });
  g.addNode(3,  {  label: "3",   label2: "DT",        nodeclass: "type-DT" });
  g.addNode(4,  {  label: "4",   label2: "This",      nodeclass: "type-TK" });
  g.addNode(5,  {  label: "5",   label2: "VP",        nodeclass: "type-VP" });
  g.addNode(6,  {  label: "6",   label2: "VBZ",       nodeclass: "type-VBZ" });
  g.addNode(7,  {  label: "7",   label2: "is",        nodeclass: "type-TK" });
  g.addNode(8,  {  label: "8",   label2: "NP",        nodeclass: "type-NP" });
  g.addNode(9,  {  label: "9",   label2: "DT",        nodeclass: "type-DT" });
  g.addNode(10, {  label: "10",   label2: "an",        nodeclass: "type-TK" });
  g.addNode(11, {  label: "11",   label2: "NN",        nodeclass: "type-NN" });
  g.addNode(12, {  label: "12",   label2: "example",   nodeclass: "type-TK" });
  g.addNode(13, {  label: "13",   label2: ".",         nodeclass: "type-." });
  g.addNode(14, {  label: "14",   label2: "sentence",  nodeclass: "type-TK" });


  g.addEdge(null, 3, 4, { label: "_1:edge 3-4",  edgeclass: "oneToMany", class: "oneToMany" });
  g.addEdge(null, 2, 3, { label: "_2:edge 2-3",  relationshipTypes: "type-1",  inArity: "one", outArity: "one",  alwaysDefined: "no",  locallyUnique: "no",  indexedBy: "date" });
  g.addEdge(null, 1, 2, { label: "_3" });
  g.addEdge(null, 6, 7, { label: "_4" });
  g.addEdge(null, 5, 6, { label: "_5" });
  g.addEdge(null, 9, 10, { label: "_6" });
  g.addEdge(null, 8, 9, { label: "_7" });
  g.addEdge(null, 3, 10, { label: "_8" });
  g.addEdge(null, 1, 10, { label: "_9" });
  g.addEdge(null, 1, 10, { label: "_10" });
  g.addEdge(null, 1, 10, { label: "_11" });
  g.addEdge(null, 1, 10, { label: "_12" });
  g.addEdge(null, 11,12, { label: "_13" });
  g.addEdge(null, 8, 11, { label: "_14" });
  g.addEdge(null, 5, 8, { label: "_15" });
  g.addEdge(null, 1, 5, { label: "_16" });
  // g.addEdge(null, 5, 5, { label: "_17" });
  g.addEdge(null, 13,14, { label: "_18" });
  // g.addEdge(null, 13,13, { label: "_19" });
  // g.addEdge(null, 1, 13, { label: "_20" });
  g.addEdge(null, 0, 1, { label: "_21" });
  g.addEdge(null, 9, 11, { label: "_22" });
  g.addEdge(null, 11, 8, { label: "_23" });
  g.addEdge(null, 14, 13, { label: "_24" })







  // we ask the renderer to draw our graph in the SVG element:
  var renderer = new dagreD3.Renderer();
  
  var oldDrawNodes = renderer.drawNodes();
  renderer.drawNodes(function(graph, root) {
    var svgNodes = oldDrawNodes(graph, root);
    
    svgNodes.each(function(u) { d3.select(this).classed(graph.node(u).nodeclass, true); });
    //Asi le añado atributos a los nodos! :)
    svgNodes.attr("id", function(u) { return "node-" + u; });
    svgNodes.attr("position", function(u) { return u.position; });

    // svgNodes.attr("lele", function(u) { return "u.length->" + label2; });  //MAL!


    return svgNodes;
  });
  
  // Disable pan and zoom
 // renderer.zoom(false);

/*  // Configuring the Layout:
  var layout = dagreD3.layout()
                      //.nodeSep(50)  //50=default
                      //.edgeSep(10)
                      //.rankSep(20);   //Separation between levels, childs
                      .rankDir("BT"); //TB:top-to-bottom / BT:bottom-to-top / LR:left-to-right / RL:right-to-left 

  // Configuring the Renderer:                    
  var rendered = renderer.layout(layout)
              //.edgeTension(.8)
              .edgeInterpolate("bundle")  // Bundle, linear, step-after, basis, cardinal, monotone..
              .run(g, d3.select("svg g"));
*/

  var layout = renderer.run(g, d3.select("svg g"));
  d3.select("svg")
/*   .append("g")
    .call(d3.behavior.zoom().scaleExtent([1, 8]).on("zoom", zoom))
    .append("g")*/
    .attr("width", layout.graph().width + 60)
    .attr("height", layout.graph().height + 60);

/*
   // Create layers
  svg
    .selectAll('g.edgePaths, g.edgeLabels, g.nodes')
    .data(['edgePaths', 'edgeLabels', 'nodes'])
    .enter()
      .append('g')
      .attr('class', function(d) { return d; });*/ 
    
  d3.select("svg.g")
    .selectAll("g.nodes")
    .data("nodes")
    .enter()
    .append("text")
    .attr("prueba", function(d) {return d; });

/*//selecting stuff
d3.selectAll(".type-DT")
    // .append("circle")
    .style("stroke","red")
    .style("stroke-width", "2px");*/

//selecting stuff
d3.selectAll(".type-DT")
    .on("click", function() {
        alert("hey! u clicking the node Nº" + renderer.drawNodes.u);
        // alert("hey! u clicking the node Nº" + oldDrawNodes();

    // .selectAll("rect")
    // .style("stroke", "yellow")
    });


d3.selectAll("path")
   .attr("stroke", "red");


d3.selectAll(".type-TK")
    .on("mouseover", function() {
          d3.select(this)
            .attr("stroke", "yellow");
    });




//no fucnionaaa
d3.selectAll("node")
    .style("stroke","green")
    .style("stroke-width", "2px");


/*
// From Renderer.js:
// Create layers
  svg
    .selectAll('g.edgePaths, g.edgeLabels, g.nodes')
    .data(['edgePaths', 'edgeLabels', 'nodes'])
    .enter()
      .append('g')
      .attr('class', function(d) { return d; });



  function defaultPostLayout() {
  // Do nothing
}

function defaultPostRender(graph, root) {
  if (graph.isDirected() && root.select('#arrowhead').empty()) {
    root
      .append('svg:defs')
        .append('svg:marker')
          .attr('id', 'arrowhead')
          .attr('viewBox', '0 0 10 10')
          .attr('refX', 8)
          .attr('refY', 5)
          .attr('markerUnits', 'strokewidth')
          .attr('markerWidth', 8)
          .attr('markerHeight', 5)
          .attr('orient', 'auto')
          .attr('style', 'fill: #333')
          .append('svg:path')
            .attr('d', 'M 0 0 L 10 5 L 0 10 z');
  }
}
*/      





/*  d3.svg.selectAll("path")
    .data([0, 0.2, 0.4, 0.6, 0.8, 1])
    .enter().append("path")
    .attr("d", function(d) { return line.tension(d)(data); });
*/

/*   var precessors = d3.select("g.predecessors("3")")
    .style("fill", "yellow");
   
   var precessors = g.predecessors("3")
    .style("fill", "yellow");*/

/*  var sinks = g.sinks();
  d3.selectAll("sinks")
    .attr("id", "sinks-manual")
    .style("fill", "red");
*/

/*  var source = Node[0]
    .style("fill", "red");
*/
/*  var source = svgNodes[0]
    .append("id", "super-source");
*/

/*  var source = d3.select("g[0]")
    .append("id", "super-source");
*/
/*  var source = d3.select("graph.node")
    .append("id", "super-source");
*/

//no fucniona zoom
/*  function zoom() {
    svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
*/

/*  //Graph-lib algos:
  layout.eachNode(function(u, value) {
    console.log("Node " + u + ": " + JSON.stringify(value));
});
*/














  // NOMENCLATURE -> u:nodes / e:edges

  // SUCCESORS, PREDECESSORS & NEIGHBORS -> LOCAL (node:node)
  // digraph.successors(u) 
  console.log(g.successors("3")); //prints 4, 10
  // digraph.predecessors(u)
  console.log(g.predecessors("3")); //prints 2 (solo conexion directa)
  // digraph.neighbors(u) -> successors + predecessors
  console.log(g.neighbors("3")); //prints 2, 4, 10

  // SOURCES, SINKS -> GLOBAL (general:node)
  // digraph.sources()
  console.log(g.sources());
  // digraph.sinks()
  console.log(g.sinks());       //prints 4, 7, 10, 12, 14

  // EXISTENCE OF EDGE (edge:true/false)
  //digraph.hasEdge(e)
  console.log(g.hasEdge("_5"));   //prints true
  console.log(g.hasEdge("_25"));  //prints false

  //digraph.edge(e, [value])
  //digraph.edge("A", "Some edge value");
  console.log(g.edge("_2", "loulou")); // mal:undefined..?


  // EDGES LIST (general: all edges)
  //digraph.edges()
  console.log(g.edges());

  //digraph.eachEdge(f) 
  var results = {};
  g.eachEdge(function(e, u, v, label, inArity, alwaysDefined) 
  {
    results[e] = "U: " + u + ", V: " + v + ", L: " + label + ", inArity: " + inArity, + ", alwaysDefined: " + alwaysDefined;  
  });
  console.log(results)
  // mal..edges labels/properties missing


  // SOURCE, TARGETS & INCIDENTS -> LOCAL  (edge:nodes)
  //digraph.source(e) +   //digraph.target(e)
  console.log(g.source("_2"));
  console.log(g.target("_2"));
  //digraph.incidentNodes(e)    -> source+target
  console.log(g.incidentNodes("_2"));

  // IN-EDGES, OUT-EDGES & INCIDENTS -> LOCAL (node:edges)
  //digraph.inEdges(target, [source])
  console.log(g.inEdges(11));  //all edges going in node10
  console.log(g.inEdges(10, 9));  //just the edge going in node10 from node9
  //digraph.outEdges(source, [target])
  console.log(g.outEdges(11)); 
  console.log(g.outEdges(5));   //all edges groing from node5. works well wiht self-linking nodes :)
  //digraph.incidentEdges(u, [v])
  console.log(g.incidentEdges(11, 8));   //inEdges+outEdges


  //ADDING/REMOVING NODES & COPY DIAGRAM
  // digraph.addNode(u, [value])
  // digraph.delNode(u)
  //digraph.copy()

  //digraph.filterNodes(f)
  // function filter(u) { return u === 1 || u === 2; }
      /*var copy = cgraph.filterNodes(filter);
      copy.nodes();
      // => [1, 2]

      copy.node(1);
      // => "node-1"

      copy.neighbors(2);
      // => [1]
    // mal.. dont understand!
*/
  //digraph.toGraph()  -> returns and undirected graph




  // ALG:

  // TARJAN: STRONGLY CONNECTED COMPONENTS
  // var tarjan = require("./tarjan");
  // var tarjan = require("./js/graphlib").alg.tarjan;
  console.log(tarjan(g))    
  //Array of components, each of them is itself an array with the ids. It gives lots of 1-array objetcs when there are no strongly connected components.

  // IS ACYCLIC, FIND CLYCLES
  // alg.isAcyclic(g)
  // console.log(isAcyclic(g));    //Gives TRUE if the graph has no cycles and returns false if it does. -ERROR: if there are cycles gives Exception isntead of False.
  // alg.findCycles(g)
    console.log(findCycles(g));     //Returns all nodes that are part of a cycle-> Arrays of these cycles if there are more.

  // TOPSORT: TOPOLOGICAL SORTING
  // var alg = require("graphlib").alg;
  // var topsort = require("graphlib").alg.topsort.
  // console.log(topsort(g));  // If the graph has a cycle it is impossible to generate such a list and CycleException is thrown. ojo! cycles include self-linking nodes
    
  // DIJKSTRA & FLOYDWARSHALL: SHORTEST PATH
  // alg.dijkstra(g, source, [weightFunc], [incidentFunc])
  // console.log(dijkstra(g, "5"));      //ERROR: anonymous function (in the js alg file)
  // alg.dijkstraAll(g, [weightFunc], [incidentFunc])
  // console.log(dijkstraAll(g));        //ERROR: anonymous function (in the js alg file)
  // alg.floydWarshall(g, [weightFunc], [incidentFunc])
  console.log(floydWarshall(g));        //Si funciona, xo da lista infinita de cosas

  // ALL CONNECTED COMPONENTS -----ERROR
  // console.log(components(g));    //NO FUNCIONA: anonymous function (in the js alg file)






  //OTHERS, not suitable for directed graphs
  //PRIM: MINIMUM SPANNING TREE
  //alg.prim(g, weightFunc)
  //PREORDER: MINIMUM SPANNING TREE
  // alg.preorder(g, root, callback)  
  //POSTORDER: MINIMUM SPANNING TREE
  // alg.postorder(g, root, callback)













  // FILTERS -> diagraph.filterNodes










/*
  d3.select(g.sinks())
    .style("fill", "red");
  
  var color = d3.scale.category20();
  d3.select.g
    .data(g.edges)
    .style("fill", function(d) { 
        return color(d,i);
      });
*/

</script>
</body>
</html>
